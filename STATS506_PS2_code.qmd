---
title: "STATS506_PS2_code"
format:
  pdf
---

## Problem 1

### Task (a)

Before we start, we need to define a random number generator to control the randomization in all 4 versions of `play_dice` function.

```{r}
#' Function to create a random number generator function
#'
#' @param seed a numeric value
#' @return a function that receives n as input and generates a n-dimensional random vector using the seed
myRng <- function(seed) {
  set.seed(seed)
  return(function(n) {
    sample(1:6, n, replace = TRUE)
  })
}
```

Then, we try to implement 4 versions of `play_dice`function.

```{r}
#' Version 1: Implement this game using a loop over the die rolls.
#' 
#' @param num_rolls an integer indicating the number of rolls
#' @param rng a function as a random number generator
#' @return total net revenue of the dice-rolls
play_dice_v1 <- function(num_rolls, rng) {
  
  # Generate the rolls using given RNG
  rolls <- rng(num_rolls)
  
  # Iterate over `num_rolls` to calculate total revenue
  revenue <- 0
  for (i in 1:num_rolls) {
    if (rolls[i] %in% c(2, 4, 6)) {
      revenue <- revenue + rolls[i]
    } 
  }
  
  # Calculate net income using net_income = revenue - cost
  cost <- 2*num_rolls
  return(revenue-cost)
}
```

```{r}
#' Version 2: Implement this game using built-in R vectorized functions.
#' 
#' @param num_rolls an integer indicating the number of rolls
#' @param rng a function as a random number generator
#' @return total net revenue of the dice-rolls
play_dice_v2 <- function(num_rolls, rng) {
  
  # Generate the rolls using given RNG
  rolls <- rng(num_rolls)

  # Calculate revenue using R vectorized function
  revenue <- sum(2*(rolls == 2)+ 4*(rolls == 4) + 6*(rolls == 6))
  
  # Calculate net income using net_income = revenue - cost
  cost <- 2*num_rolls
  return(revenue-cost)
}
```

```{r}
#' Version 3: Implement this by collapsing the die rolls into a single table().
#' 
#' @param num_rolls an integer indicating the number of rolls
#' @param rng a function as a random number generator
#' @return total net revenue of the dice-rolls
play_dice_v3 <- function(num_rolls, rng) {
  
  # Generate the rolls using given RNG
  rolls <- rng(num_rolls)
  
  # Collapse the die rolls into a single table
  roll_counts <- table(rolls)

  # Iterate over items in the table
  # Notice that the length of the table can be 6 at most. So this is not computationally costly.
  revenue <- 0
  for (i in names(roll_counts)){
    if (as.numeric(i) == 2){
      revenue <- revenue + 2*roll_counts[as.character(i)]
      next
    }
    if (as.numeric(i) == 4){
      revenue <- revenue + 4*roll_counts[as.character(i)]
      next
    }
    if (as.numeric(i) == 6){
      revenue <- revenue + 6*roll_counts[as.character(i)]
    }
  }
  revenue <- as.numeric(revenue)
  
  # Calculate net income using net_income = revenue - cost
  cost <- 2*num_rolls
  return(revenue-cost)
}
```

```{r}
#' Version 4: Implement this game by using one of the “apply” functions.
#' 
#' @param num_rolls an integer indicating the number of rolls
#' @param rng a function as a random number generator
#' @return total net revenue of the dice-rolls
play_dice_v4 <- function(num_rolls, rng) {
  
  # Generate the rolls using given RNG
  rolls <- rng(num_rolls)
  
  # Use "apply" to calculate the revenue
  # To use "apply", we choose to convert vector "rolls" into a matrix
  revenue <- sum(apply(matrix(rolls, ncol = num_rolls), 2, function(row) {
    if (row %in% c(2,4,6)){
      return(row)
    } else{
      return(0)
    }
  }))
  
  # Calculate net income using net_income = revenue - cost
  cost <- 2*num_rolls  
  return(revenue-cost)
}
```

### Task (b)

In this task, we will show that all versions work. Notice that we will pass a random number into the function `myRng`, since we do not need to fix the result at this moment.

```{r}
for (t in c(3,3000)) {
  cat("Result for ", t, " using v1 is ", play_dice_v1(t, myRng(sample.int(1000, 1))), "\n")
  cat("Result for ", t, " using v2 is ", play_dice_v2(t, myRng(sample.int(1000, 1))), "\n")
  cat("Result for ", t, " using v3 is ", play_dice_v3(t, myRng(sample.int(1000, 1))), "\n")
  cat("Result for ", t, " using v4 is ", play_dice_v4(t, myRng(sample.int(1000, 1))), "\n")
}
```

### Task (c)

In this task, we will show that the four versions give the same result. We will control the randomization by putting the same seed to RNG.

```{r}
seed <- 114
for (t in c(3,3000)) {
  cat("Result for ", t, " using v1 is ", play_dice_v1(t, myRng(seed)), "\n")
  cat("Result for ", t, " using v2 is ", play_dice_v2(t, myRng(seed)), "\n")
  cat("Result for ", t, " using v3 is ", play_dice_v3(t, myRng(seed)), "\n")
  cat("Result for ", t, " using v4 is ", play_dice_v4(t, myRng(seed)), "\n")
}
```

It is clear that the four versions give the same result.

### Task (d)

First, we need to import `microbenchmark` library.

```{r}
#| code-fold: true
library(microbenchmark)
```

Then, we test the performance with a low input.

```{r}
# Benchmark with low input (100)
seed <- 896
benchmark_low <- microbenchmark(
  v1 = play_dice_v1(100, myRng(seed)),
  v2 = play_dice_v2(100, myRng(seed)),
  v3 = play_dice_v3(100, myRng(seed)),
  v4 = play_dice_v4(100, myRng(seed)),
  times = 100
)
print(benchmark_low)
```

And we test the performance with a large input.

```{r}
# Benchmark with large input (10000)
benchmark_large <- microbenchmark(
  v1 = play_dice_v1(10000, myRng(seed)),
  v2 = play_dice_v2(10000, myRng(seed)),
  v3 = play_dice_v3(10000, myRng(seed)),
  v4 = play_dice_v4(10000, myRng(seed)),
  times = 100
)
print(benchmark_large)
```

Notice that the scale of time using each version differs largely. So, we may take log-transformation of time to make the plot.

```{r}
log_time_low <- benchmark_low
log_time_low$time <- log(benchmark_low$time)
plot(log_time_low, xlab = "version", ylab = "log of time", main = "Benchmark_low")
```

By the boxplot, we can see that for low input, the running time for v1 and v3 are close to each other. And v2 is the fastest one while v4 is the lowest one on average.

```{r}
log_time_large <- benchmark_large
log_time_large$time <- log(benchmark_large$time)
plot(log_time_large, xlab = "version", ylab = "time", main = "Benchmark_large")
```

By the boxplot, we can see that for large input, running time for 4 versions can be ranked as $v2 < v3<v1<v4$ on average.

### Task (e)

For convenience, we will only use `play_dice_v2` in this problem, since the results of 4 versions of function are the same. In a single call of `play_dice_v2` function, we will roll the dice `num_rolls` of times. And we will record the average net income per roll among `num_rolls` times of dice rolls.

In the following Monte Carlo simulation, we will choose 3 different values for `num_rolls`, which are $3,30,300$. And we will repeat this experiment for 100 times.

```{r}
reps <- 100

# Create 3 empty vectors to record the result
n3 <- vector(length = reps)
n30 <- vector(length = reps)
n300 <- vector(length = reps)

# Monte Carlo simulation
for (i in seq_len(reps)) {
  n3[i] <- play_dice_v2(3,myRng(sample.int(1000, 1)))/3
  n30[i] <- play_dice_v2(30,myRng(sample.int(1000, 1)))/30
  n300[i] <- play_dice_v2(300,myRng(sample.int(1000, 1)))/300
}

```

Here, we can plot our result on using boxplot.

```{r}
boxplot(data.frame(n3, n30, n300))
```

We can see for $n_{30}$ and $n_{300}$, the average net income per roll is very close to 0. This is not surprising because theoretically,

$$
\mathbb{E}(net\:income)=\mathbb{E}(revenue)-\mathbb{E}(cost)=\frac{1}{6}(0+2+0+4+0+6)-2=0
$$

Therefore, we can conclude that this game is a fair game.

## Problem 2

```{r}
data <- read.csv("./cars.csv")
data <- data.frame(data)
```

```{r}
colnames(data) <- c("height", "length", "width", "driveLine", "engineType", "isHybrid", "numGears", "transmission", "cityMPG", "fuelType", "highwayMPG", "classification", "ID", "make", "modelYear", "IDYear", "horsepower", "torque")
```

```{r}
data <- data[which(data$fuelType == "Gasoline"),]
```

```{r}
M1 <- lm(highwayMPG~horsepower+numGears+cityMPG+torque, data = data)
summary(M1)
```

```{r}
#library(emmeans)
```

```{r}
#M2 <- lm(highwayMPG~horsepower*torque, data = data)
#interact_plot(M2, pred = horsepower, modx = torque)
```

```{r}
#library(imager)
```

```{r}
#file_path <- system.file("./q2.jpg",package='imager') 
#im <- load.image("./q2.jpg")
#plot(1:10,ty="n")
#rasterImage(im,2,1,10,10)
```
